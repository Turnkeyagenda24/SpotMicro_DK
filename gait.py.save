import time

class GaitController:
    STEP_DURATION = 0.5  # full step cycle per pair
    LIFT_HEIGHT = 5
    PAIR_1 = ['FR', 'BL']
    PAIR_2 = ['FL', 'BR']

    def __init__(self):
        self.STEP_LENGTH = 0
        self.phase = 0.0  # Current phase from 0 to 1
        self.start_time = time.time()
        self.just_started = True
        self.start_count = 0

    def square_step_phase(self, phase, base_x, base_y, base_z):

        swing_start_y = base_y - self.STEP_LENGTH

        if phase < 0.25:
            # Lift quickly
            z = base_z + self.LIFT_HEIGHT * (phase / 0.25)
            y = base_y if self.just_started else swing_start_y

        elif phase < 0.5:
            # Move forward
            z = base_z + self.LIFT_HEIGHT
            y = base_y + self.STEP_LENGTH * ((phase - 0.25) / 0.25)
        elif phase < 0.75:
            # Lower down
            z = base_z + self.LIFT_HEIGHT * (1 - (phase - 0.5) / 0.25)
            y = base_y + self.STEP_LENGTH
        else:
            # Move backward while foot is on ground
            z = base_z
            y = base_y + self.STEP_LENGTH * (1 - (phase - 0.75) / 0.25)

        return (base_x, y, z)

    def get_crawl_targets(self, pos_x, pos_y, pos_z, hip_x_offsets, current_positions):

        BODY_SHIFT_AMOUNT = 5  # in mm, tune this
        body_shift_x = 0

        NUM_PHASES = 8
        now = time.time()
        elapsed = now - self.start_time
        total_cycle_time = self.STEP_DURATION * NUM_PHASES
        current_phase = (elapsed % total_cycle_time) / total_cycle_time  # 0–1 over full gait

        # Define phase offsets (FL starts first, then clockwise or custom)
        leg_offsets = {
            'FL': 2,
            'FR': 6,
            'BR': 4,
            'BL': 0
        }

        # Determine which leg is in swing phase (approximate)
        swinging_leg = None
        min_phase_diff = 1.0
        for leg_id in ['FL', 'FR', 'BL', 'BR']:
            phase_offset = leg_offsets[leg_id] / NUM_PHASES
            leg_phase = (self.phase - phase_offset) % 1.0
            if leg_phase < 1.0 / NUM_PHASES and leg_phase < min_phase_diff:
                min_phase_diff = leg_phase
                swinging_leg = leg_id

        if swinging_leg == 'FL' or swinging_leg == 'BL':
            body_shift_x = +BODY_SHIFT_AMOUNT  # shift to right side
        elif swinging_leg == 'FR' or swinging_leg == 'BR':
            body_shift_x = -BODY_SHIFT_AMOUNT  # shift to left side

        target_positions = {}

        for leg_id in ['FL', 'FR', 'BL', 'BR']:
            base_x = pos_x + body_shift_
            base_y = pos_y
            base_z = pos_z

            # Each leg gets its own offset in the gait cycle
            phase_offset = leg_offsets[leg_id] / NUM_PHASES
            leg_phase = (current_phase - phase_offset) % 1.0

            if leg_phase < 1.0 / NUM_PHASES:
                # Swing phase (lift–forward–down)
                swing_phase = leg_phase * NUM_PHASES  # normalize to 0–1
                target = self.square_step_phase(swing_phase, base_x, base_y, base_z)
            else:
                # Stance phase — slow backward slide
                stance_phase = (leg_phase - 1 / NUM_PHASES) / (1 - 1 / NUM_PHASES)
                y = base_y + self.STEP_LENGTH / 2 - self.STEP_LENGTH * stance_phase
                z = base_z
                target = (base_x, y, z)

            target_positions[leg_id] = target

        return target_positions

    def stance_slide_phase(self, phase, base_x, base_y, base_z):
        if phase < 0.75:
            return (base_x, base_y, base_z)
        else:
            progress = (phase - 0.75) / 0.25
            y = base_y - self.STEP_LENGTH * progress
            return (base_x, y, base_z)

    def get_walk_targets(self, pos_x, pos_y, pos_z, hip_x_offsets, current_positions, interpolation_tolerance=0.3, phase_increment=0.1):
        # current_positions is a dict leg_id -> (x, y, z) from interpolator output

        target_positions = {}
        all_close = True

        for leg_id in ['FL', 'FR', 'BL', 'BR']:
            base_x = pos_x  # X left/right
            base_y = pos_y
            base_z = pos_z

            # Determine which pair the leg is in
            if leg_id in self.PAIR_1:
                leg_phase = self.phase % 1.0
                in_swing = leg_phase < 0.5
                swing_phase = (leg_phase * 2) % 1.0  # Normalize to 0–1
            else:
                leg_phase = (self.phase + 0.5) % 1.0  # shift phase for pair 2
                in_swing = leg_phase < 0.5
                swing_phase = (leg_phase * 2) % 1.0

            if in_swing:
                target = self.square_step_phase(swing_phase, base_x, base_y, base_z)
            elif swing_phase >= 0.75:
                # Stance leg slides back only while swing leg is doing last 25%
                target = self.stance_slide_phase(swing_phase, base_x, base_y, base_z)

            else:
                target = (base_x, base_y, base_z)

            target_positions[leg_id] = target

            # Check distance from current position to target
            cx, cy, cz = current_positions.get(leg_id, target)
            tx, ty, tz = target
            dist = ((tx - cx)**2 + (ty - cy)**2 + (tz - cz)**2)**0.5
            if dist > interpolation_tolerance:
                all_close = False

        # Advance phase only if all legs are close to their targets
        if all_close:
            self.phase += phase_increment
            if self.phase >= 1.0:
                self.phase -= 1.0
            elif self.phase>= 0.5:
                self.just_started = False
        return target_positions
